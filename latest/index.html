<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · LazyContext.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>LazyContext.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="LazyContext.jl-1" href="#LazyContext.jl-1">LazyContext.jl</a></h1><p><code>LazyContext</code> makes true lazy evaluation easy. Here is a simple port of <code>with</code> in R.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; with(d::WithContext, e::WithContext) = begin
           d_evaluated = evaluate!(d)
           e_copy = copy(e)
           merge!(e_copy.environment, d_evaluated)
           evaluate!(e_copy)
       end;

julia&gt; @new_environment;

julia&gt; @import_to_environment with;

julia&gt; @evaluate begin
           d = Dict(:a =&gt; 1, :b =&gt; 2)
           @with d a + b
       end
3</code></pre><p>Merging will work for any type which can be key-value iterated.</p><ul><li><a href="index.html#LazyContext.Environment"><code>LazyContext.Environment</code></a></li><li><a href="index.html#LazyContext.WithContext"><code>LazyContext.WithContext</code></a></li><li><a href="index.html#LazyContext.copy_of_base_environment-Tuple{}"><code>LazyContext.copy_of_base_environment</code></a></li><li><a href="index.html#LazyContext.evaluate!-Tuple{Any}"><code>LazyContext.evaluate!</code></a></li><li><a href="index.html#LazyContext.immutable_merge-Tuple{Any,Any}"><code>LazyContext.immutable_merge</code></a></li><li><a href="index.html#LazyContext.@evaluate-Tuple{Any}"><code>LazyContext.@evaluate</code></a></li><li><a href="index.html#LazyContext.@import_to_environment-Tuple"><code>LazyContext.@import_to_environment</code></a></li><li><a href="index.html#LazyContext.@new_environment-Tuple{}"><code>LazyContext.@new_environment</code></a></li><li><a href="index.html#LazyContext.@use_in_environment-Tuple"><code>LazyContext.@use_in_environment</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.Environment" href="#LazyContext.Environment"><code>LazyContext.Environment</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">type Environment
    dictionary::Base.ImmutableDict{Symbol,Any}()
end</code></pre><p>A type to store all the names in your local environment.</p><p>Can access and record new values in an environment.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; e = Environment();

julia&gt; e[:a] = 1;

julia&gt; e
Environment. Most recent assignment: a

julia&gt; e[:a]
1</code></pre><p>By default, contains an <code>:ENVIRONMENT</code> key which points to itself. If the environment has a parent, it also will contain a <code>:PARENT</code> key which points to its parent.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; e = Environment();

julia&gt; e[:a] = 1;

julia&gt; e[:ENVIRONMENT][:a]
1

julia&gt; e2 = copy(e);

julia&gt; e2[:PARENT][:a]
1

julia&gt; e2[:b] = 1;

julia&gt; e2[:PARENT][:b]
ERROR: KeyError: key :b not found
[...]</code></pre><p>Can <code>merge!</code> or <code>merge</code> new objects into an environment. You can merge in modules:</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; e = Environment();

julia&gt; merge!(e, Core);

julia&gt; e[:Symbol]
Symbol</code></pre><p>and dictonaries:</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; e = Environment();

julia&gt; merge!(e, Dict(:a =&gt; 1) );

julia&gt; e[:a]
1</code></pre><p>Extend <a href="index.html#LazyContext.immutable_merge-Tuple{Any,Any}"><code>immutable_merge</code></a> to be able to merge in more types.</p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L3-L78">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.WithContext" href="#LazyContext.WithContext"><code>LazyContext.WithContext</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">type WithContext
    expression::Any
    environment::Environment
end</code></pre><p>An expression in the context of its <a href="index.html#LazyContext.Environment"><code>Environment</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L200-L207">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.copy_of_base_environment-Tuple{}" href="#LazyContext.copy_of_base_environment-Tuple{}"><code>LazyContext.copy_of_base_environment</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">copy_of_base_environment()</code></pre><p>Get an environment which contains <code>Core</code> and <code>Base</code>. Has no parent.</p></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L115-L119">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.evaluate!-Tuple{Any}" href="#LazyContext.evaluate!-Tuple{Any}"><code>LazyContext.evaluate!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">evaluate!(w; locked = false)</code></pre><p>Evaluate <code>w.expression</code> in context of <code>w.environment</code>.</p><p>Unlocked environments cannot be directly accessed in a type stable way. If you include the <code>locked = true</code> keyword, however, the bindings in the <code>environment</code> will be fixed allowing for type-stable access.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; ENVIRONMENT[:a] = 1;

julia&gt; ENVIRONMENT[:b] = 2;

julia&gt; w = WithContext(:(a + b), ENVIRONMENT);

julia&gt; evaluate!(w)
3

julia&gt; evaluate!(w, locked = true)
3

julia&gt; evaluate!( WithContext(:(a = 1), ENVIRONMENT), locked = true)
ERROR: Cannot assign 1 to a: environment is locked
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/evaluate.jl#L18-L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.immutable_merge-Tuple{Any,Any}" href="#LazyContext.immutable_merge-Tuple{Any,Any}"><code>LazyContext.immutable_merge</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">immutable_merge(d, a)</code></pre><p>Merge <code>d</code> (usually an <code>ImmutableDict</code>) and <code>a</code> into a new <code>ImmutableDict</code>. For example:</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; d = Base.ImmutableDict{Symbol, Any}();

julia&gt; a = Dict(:b =&gt; 2);

julia&gt; immutable_merge(d, a)[:b]
2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/utilities.jl#L4-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.@evaluate-Tuple{Any}" href="#LazyContext.@evaluate-Tuple{Any}"><code>LazyContext.@evaluate</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">macro evaluate(expression)</code></pre><p><a href="index.html#LazyContext.evaluate!-Tuple{Any}"><code>evaluate!</code></a> <code>expression</code> in the context of <code>ENVIRONMENT</code>.</p><p>Only limited syntax is supported inside <code>@evaluate</code>.</p><p>Anonymous are suppported, but only using the terse syntax.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; @evaluate begin
           test_function = (a, b...; c = 1) -&gt; +(a, c, b...)
           test_function(1, 2, 3; c = 4)
       end
10</code></pre><p>Anonymous functions create new environments. The parent environment can be accessed with <code>PARENT</code>, while the local environment can be accessed with <code>ENVIRONMENT</code>.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; @evaluate begin
           a = 1
           test = b -&gt; begin
               merge!(ENVIRONMENT, Dict(:a =&gt; 2))
               a + b + PARENT[:a]
           end
           test(3)
       end
6</code></pre><p>Anonymous functions use dynamic scoping: changes in global variables will change functions which reference them.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; (3, 4) == @evaluate begin
           a = 1
           test = b -&gt; a + b
           first_result = test(2)
           a = 2
           second_result = test(2)
           first_result, second_result
       end
true</code></pre><p>Macro calls do not call macros. Instead, they create <code>WithContext</code> expression wrappers out of all arguments and pass them to the function with the same name.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; e = @evaluate begin
           a = 1
           b = 2
           @identity a + b
       end
WithContext(a + b)

julia&gt; evaluate!(e)
3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/evaluate.jl#L56-L134">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.@import_to_environment-Tuple" href="#LazyContext.@import_to_environment-Tuple"><code>LazyContext.@import_to_environment</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">macro import_to_environment(args...)</code></pre><p>Make <code>args</code>, a list of names, available in the global <code>ENVIRONMENT</code>.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; import MacroTools;

julia&gt; @import_to_environment LazyContext MacroTools;

julia&gt; Environment == @evaluate LazyContext.Environment
true

julia&gt; MacroTools.prettify == @evaluate MacroTools.prettify
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L144-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.@new_environment-Tuple{}" href="#LazyContext.@new_environment-Tuple{}"><code>LazyContext.@new_environment</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">macro new_environment</code></pre><p>Will create a new <a href="index.html#LazyContext.copy_of_base_environment-Tuple{}"><code>copy_of_base_environment</code></a> named <code>ENVIRONMENT</code>. Prerequisite for many macros in this package. Be careful not to overwrite <code>ENVIRONMENT</code>.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; Dict == ENVIRONMENT[:Dict]
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L123-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LazyContext.@use_in_environment-Tuple" href="#LazyContext.@use_in_environment-Tuple"><code>LazyContext.@use_in_environment</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">use_in_environmnet(args...)</code></pre><p>Make the contents of each item in <code>args</code> available in the global <code>ENVIRONMENT</code>, by merging in each one by one.</p><pre><code class="language-jlcon">julia&gt; using LazyContext

julia&gt; @new_environment;

julia&gt; import MacroTools;

julia&gt; @use_in_environment LazyContext MacroTools;

julia&gt; Environment == @evaluate Environment
true

julia&gt; MacroTools.prettify == @evaluate prettify
true</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bramtayl/LazyContext.jl/tree/f7d3a1de4dbf96a1e4bd70d6ec39775f66094337/src/environment.jl#L173-L194">source</a><br/></section><footer><hr/></footer></article></body></html>
